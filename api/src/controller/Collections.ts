import { ICollection } from "@ts/collections";
import { Collection } from "../Classes/Collection";
import { IChangeCollectionLockInput, ICollectionInput, ICollectionMetaInput } from "../types/collections";

import db from "../model/db";
import globalErrorHandler from "../misc/globalErrorHandler";
import { IContext } from "@ts-backend/context";
import CustomDate from "../Classes/CustomDate";
import StatsItem from "../Classes/StatsItem";

class CollectionsController {
	async getCollection({ id }: { id: string }): Promise<ICollection> {
		let result;

		try {
			result = await db.collection("collections").findOne({ id });

			if(!result) throw new Error("404. Collection not found");
		}
		catch(e: any) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}
		
		return result;
	}

	async getCollectionsByProfile({ id }: { id: string }): Promise<ICollection[]> {
		let result;
		
		try {
			let cursor = await db.collection("collections").find({
				profile: id
			});

			result = (await cursor.toArray()).filter((col: ICollection) => !col.isAutoGenerated);
		}
		catch(e: any) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}

		return result;
	}

	async getProfileCollectionsCount({ profileId }: { profileId: string }) {
		let result;
		
		try {
			let cursor = await db.collection("collections").find({
				profile: profileId,
				isAutoGenerated: {
					$ne: true
				}
			});

			result = await cursor.count();
		}
		catch(e: any) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}

		return result;
	}

	async createCollection({ input }: { input: ICollectionInput }, context: IContext) {
		const collection: Partial<ICollection> = new Collection(input, context.auth.userId);
		collection.userId = context.auth.userId;

		try {
			await db.collection("collections").insertOne(collection);
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to create collection. ${e}`);
		}

		await this._updateStats(input.profile, input.day);

		return collection;
	}

	async mutateCollection({ id, input }: { id: string, input: ICollectionInput}) {
		let updatedCollection;

		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					name: input.name,
					color: input.color
				}
			});
			
			updatedCollection = await db.collection("collections").findOne({ id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to mutate collection. ${e}`);
		}

		return updatedCollection;
	}

	async mutateCollectionMeta({ id, input }: { id: string, input: ICollectionMetaInput }) {
		let collection;

		try {
			collection = await db.collection("collections").findOne({ id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}

		if(!collection) throw new Error("404. Collection not found");

		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					"meta.repetitionsCount": collection.meta.repetitionsCount + input.repetitionsCount,
					"meta.lastRepetition": input.lastRepetition
				}
			})
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed edit collection meta. ${e}`);
		}

		return "OK";
	}

	async changeCollectionLock({ id, input }: { id: string, input: IChangeCollectionLockInput}) {
		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					isLocked: input.isLocked
				}
			})
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to lock/unlock collection. ${e}`);
		}

		return "OK";
	}

	async deleteCollection({ id }: { id: string }) {
		try {
			await db.collection("phrases").deleteMany({ collection: id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to delete collection phrases. ${e}`);
		}

		try {
			await db.collection("collections").deleteOne({ id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to delete collection. ${e}`);
		}

		return "OK";
	}

	async _updateStats(profile: string, day: number) {
		let todayStats;

		try {
			todayStats = await db.collection("stats").findOne({ profileId: profile, day });
		} catch(e) {
			globalErrorHandler(e);
			throw new Error(`Failed to obtain stats for update ${e}`);
		}

		try {
			if(!todayStats) {
				const stats = new StatsItem(profile, day);
				stats.createdCollections++;
	
				await db.collection("stats").insertOne(stats);
			} else {
				await db.collection("stats").updateOne({ _id: todayStats._id }, {
					$set: {
						createdCollections: todayStats.createdCollections + 1,
					}
				})
			}
		} catch(e) {
			globalErrorHandler(e);
			throw new Error(`Failed to update stats ${e}`);
		}
	}
}

export default new CollectionsController();
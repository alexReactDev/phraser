import { ICollection } from "types/collections";
import { Collection } from "../Classes/Collection";
import { IChangeCollectionLockInput, ICollectionInput, ICollectionMetaInput } from "../types/collections";

import db from "../model/db";
import globalErrorHandler from "../misc/globalErrorHandler";
import { IJWT } from "@ts-backend/authorization";

class CollectionsController {
	async getCollection({ id }: { id: string }): Promise<ICollection> {
		let result;

		try {
			result = await db.collection("collections").findOne({ id });

			if(!result) throw new Error("404. Collection not found");
		}
		catch(e: any) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}
		
		return result;
	}

	async getCollectionsByProfile({ id }: { id: string }): Promise<ICollection[]> {
		let result;
		
		try {
			let cursor = await db.collection("collections").find({
				profile: id
			});

			result = (await cursor.toArray()).filter((col: ICollection) => !col.isAutoGenerated);
		}
		catch(e: any) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}

		return result;
	}

	async getCollectionByPhrase({ id }: { id: string }): Promise<ICollection> {
		let result;

		try {
			result = await db.collection("collections").findOne({
				phrases: { $in: [id] }
			});

			if(!result) throw new Error("404. Collection not found");
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to find collection. ${e}`);
		}

		return result;
	}

	async createCollection({ input }: {input: ICollectionInput}, context: { auth: IJWT }) {
		const collection: Partial<ICollection> = new Collection(input.name, input.color, input.profile, context.auth.userId);
		collection.userId = context.auth.userId;

		try {
			await db.collection("collections").insertOne(collection);
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to create collection. ${e}`);
		}

		return "OK";
	}

	async mutateCollection({ id, input }: { id: string, input: ICollectionInput}) {
		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					name: input.name,
					color: input.color
				}
			})
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to mutate collection. ${e}`);
		}

		return "OK";
	}

	async mutateCollectionMeta({ id, input }: { id: string, input: ICollectionMetaInput }) {
		let collection;

		try {
			collection = await db.collection("collections").findOne({ id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to get collection. ${e}`);
		}

		if(!collection) throw new Error("404. Collection not found");

		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					"meta.repetitionsCount": collection.meta.repetitionsCount + input.repetitionsCount,
					"meta.lastRepetition": input.lastRepetition
				}
			})
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed edit collection meta. ${e}`);
		}

		return "OK";
	}

	async changeCollectionLock({ id, input }: { id: string, input: IChangeCollectionLockInput}) {
		try {
			await db.collection("collections").updateOne({ id }, {
				$set: {
					isLocked: input.isLocked
				}
			})
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to lock/unlock collection. ${e}`);
		}

		return "OK";
	}

	async deleteCollection({ id }: { id: string }) {
		try {
			await db.collection("collections").deleteOne({ id });
		} catch (e) {
			globalErrorHandler(e);
			throw new Error(`Server error. Failed to delete collection. ${e}`);
		}

		return "OK";
	}
}

export default new CollectionsController();